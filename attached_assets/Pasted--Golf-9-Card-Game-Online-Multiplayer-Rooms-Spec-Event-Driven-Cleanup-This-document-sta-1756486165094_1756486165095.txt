# Golf 9 Card Game — Online Multiplayer **Rooms** Spec (Event‑Driven Cleanup)

> This document standardizes language on **rooms** (no “lobbies”), preserves your existing logic/behaviors, and replaces interval cleanup with **event‑driven, immediate** cleanup/delisting.

---

## I. Core Architecture (unchanged intent)

* **Authoritative server, dumb clients.** Server validates all moves, owns the clock, and is the single source of truth. Clients render + emit intents.
* **Optimistic UI + reconciliation.** Client animates local action; server echoes authoritative result. On mismatch, client snaps to server state.
* **Time sync.** Server timestamps all actions; clients render timers from `serverTs` (e.g., turn timeout).

---

## II. Terminology

* **Room:** Multiplayer waiting/playing container (public or private).
* **Room List (Hub):** Two panels in the main multiplayer screen:

  * **Active Rooms:** Public rooms in **Waiting** state and **not full** (joinable).
  * **Private Rooms:** Private rooms a user can join **only** with password or direct friend invite.
* **Host:** First player in a room; has special privileges and a crown icon.
* **States:** `waiting` → `active` → `finished`.
* **Player count:** `X/Y` where `Y = maxPlayers` (2–4).

---

## III. Entities & Data Model (contract-level)

**Room**

* `id` (uuid), `code` (6-char), `name`, `visibility` (`public`|`private`), `passwordHash?`
* `hostId` (player id)
* `maxPlayers` (2–4), `rounds` (5|9), `betCoins` (0–100)
* `state` (`waiting`|`active`|`finished`)
* `players[]` (ordered by `joinOrder`)
* `createdAt`, `updatedAt`, `lastActivityAt`
* **Constraints:** enforce `playerCount ≤ maxPlayers`; unique membership `(roomId, playerId)` to prevent duplicate joins.

**Player (in-room)**

* `id`, `name`, `avatarUrl?`, `joinOrder` (1…n)
* `isHost` (derived: `id === hostId`)
* `ready` (bool; waiting-only)
* `connected` (bool), `lastSeenAt`
* `scoreByRound[]`, `totalScore`

**AuditLog (append-only)**

* `id`, `type` (payout, bet\_change, host\_transfer, etc.), `roomId`, `actorId`, `payload`, `createdAt`

---

## IV. Room Lifecycle & Room List Rules

All updates are **real-time** and emitted **after the mutating DB transaction commits**.

**Create Room**

1. Persist room (`state=waiting`, `playerCount=1`).
2. Broadcast `ROOM_CREATED` + `ROOM_UPDATED`.
3. **Room List:** If **public** and **not full**, appears in **Active Rooms** immediately (`1/Y`).

**Join Room**

1. Add player; increment count.
2. Broadcast `PLAYER_JOINED` + `ROOM_UPDATED`.
3. If room becomes **full** (waiting & `X==Y`), **immediately delist** from Active Rooms.

**Leave (voluntary)**

1. Mark membership left; decrement count.
2. Broadcast `PLAYER_LEFT` + `ROOM_UPDATED`.
3. If it was full and now has space, **immediately relist** in Active Rooms.
4. If **count==0**, **delete room now** + broadcast `ROOM_DELETED`.

**Disconnect (browser close/network)**

* WebSocket breaks ⇒ mark as **left immediately** for counts and remove from in-memory seat.
* **If state=active:** AI takes over instantly; player has **5 minutes** to rejoin and reclaim their seat; game continues.
* **If last player leaves/disconnects:** `playerCount==0` ⇒ **purge room immediately** (see Section XV Rule #1).

**Settings change (host)**

1. Persist new settings.
2. Broadcast `SETTINGS_UPDATED` + `ROOM_UPDATED`.
3. Room cards/room UI reflect changes in real time.

**Ready toggle (waiting)**

* Persist `ready`; broadcast `PLAYER_READY_CHANGED` (does not affect Room List).

**Auto-start**

* Trigger when **min 2 players** and **all players ready**.
* Lock settings; set `state=active`; broadcast `GAME_STARTED`.
* **Immediately delist** from Active Rooms (not joinable).

**Game end**

* Set `state=finished`. Either **delete** room or **reset** to `waiting`; if reset to a joinable public room, **relist immediately**.

---

## V. Room Creation & Configuration

* **Host:** First joiner becomes host (crown indicator).
* **Config (host-only; waiting state):**

  * `rounds`: 5 or 9
  * `maxPlayers`: 2–4
  * `betCoins`: 0–100
  * `visibility`: `public` or `private`

    * **Private:** locked icon; join via password or direct friend invite only.
* **Codes:** Auto-generate 6-character `room.code`.
* **Real-time settings sync** across all clients.

**Room States**

* `waiting`: players join; settings modifiable.
* `active`: game in progress; no new joins.
* `finished`: results visible; may reset or delete.

---

## VI. Game Flow

**Pre-Game (Waiting)**

* Real-time join/leave notifications.
* Ready/Not Ready toggle per player (green checkmarks).
* Show connected player avatars/names.

**Auto-Start**

* When **all players ready** and **≥2 players**: broadcast `GAME_STARTED`; sync initial state.

**Game Initialization**

* Hide waiting UI; initialize server state; send authoritative snapshot.

**In-Game**

* Turn-based:

  * Current player indicator.
  * Validate actions on server **before** broadcasting.
  * Animate card moves in real time.
  * Update scores at end of each round.
* Connection resilience:

  * “Connection lost” modal with retry.
  * Rejoin: if within 5 minutes in an active game, reclaim seat; otherwise treated as a fresh join (and may be blocked if full/active).

---

## VII. Host System

* Host badge (gold crown).
* **Deterministic host migration:** next host = **lowest `joinOrder` still connected**; broadcast `HOST_CHANGED`.

---

## VIII. Edge Cases & Business Rules

**Room Management**

* Auto-delete rooms with **0 players** (immediate; event-driven).
* Enforce **max 4 players** per room.
* Prevent duplicate joins via DB uniqueness.

**Game Start Conditions**

* **Min 2 players**.
* **All players ready** (for auto-start).
* **Lock settings** once game begins.

**Disconnection Handling**

* **5-minute timeout** to reconnect (active games only).
* **AI auto takeover** for disconnected players.
* **Game always continues** until all rounds complete (unless `playerCount==0` ⇒ purge).

---

## IX. Security & Abuse Prevention

* **Rate limits** & flood protection per IP/user/room.
* **Audit log** (append-only) for payouts, bet changes, host transfers.

---

## X. Client–Server Realtime Contracts (Socket events)

### Client → Server (intents)

* `room:create` `{ name?, visibility, password?, maxPlayers, rounds, betCoins }`
* `room:join` `{ code, password? }`
* `room:leave` `{ code }`
* `room:list:subscribe` `{}` / `room:list:unsubscribe` `{}`
* `room:settings:update` `{ code, patch: { maxPlayers?, rounds?, betCoins?, visibility?, password? } }` (host-only)
* `room:ready:set` `{ code, ready: boolean }`
* `game:start` `{ code }` (optional manual trigger if you add a Start button for host; auto-start still applies)
* `move:submit` `{ code, turnId, action, payload, clientOpId, clientTs }`
* `session:ping` `{ ts }` (keepalive/latency if needed)

### Server → Client (authoritative)

* `room:created` `{ room }`
* `room:updated` `{ code, changes, serverTs }` (playerCount, settings, state, etc.)
* `room:deleted` `{ code }`
* `room:list:snapshot` `{ rooms: RoomCard[] }` (on subscribe)
* `room:list:diff` `{ added?: RoomCard[], updated?: RoomCard[], removed?: string[] }`
* `player:joined` `{ code, player }`
* `player:left` `{ code, playerId }`
* `player:readyChanged` `{ code, playerId, ready }`
* `host:changed` `{ code, hostId }`
* `game:started` `{ code, initialState, serverTs }`
* `game:state` `{ code, state, serverTs }` (periodic or on change)
* `move:accepted` `{ code, turnId, serverOpId, clientOpId?, appliedDelta, newState, serverTs }`
* `move:rejected` `{ code, turnId, clientOpId, reason, serverTs }` (client must snap to `hintState?` if provided)
* `score:updated` `{ code, roundIndex, scores, totals }`
* `timer:tick` `{ code, turnId, msRemaining, serverTs }`
* `error` `{ code, message, context? }`

**RoomCard (for lists)**

```json
{
  "code": "ABC123",
  "name": "John's Room",
  "visibility": "public",
  "isLocked": false,
  "hostName": "John",
  "hostHasCrown": true,
  "playerCount": 2,
  "maxPlayers": 4,
  "rounds": 9,
  "betCoins": 10,
  "state": "waiting" // waiting|active|finished
}
```

**Invariants for the Room List**

* A public room is listed in **Active Rooms** iff `state=="waiting" && playerCount < maxPlayers`.
* When a waiting room becomes full (`playerCount==maxPlayers`), it is **removed** from Active Rooms **immediately**.
* When a previously full waiting room loses a player, it is **relisted immediately**.
* Rooms with `playerCount==0` are **deleted immediately** and removed.

---

## XI. Optimistic UI & Reconciliation Rules

* Each client action includes `clientOpId` and `clientTs`.
* Server responds with `move:accepted` (authoritative `serverOpId`, `serverTs`) or `move:rejected`.
* On **accepted**, client reconciles deltas; on **rejected**, client **snaps** to authoritative state or requests `game:state`.
* All timers derive from **serverTs**, not local clock.

---

## XII. Disconnection & Rejoin

* **Waiting state:** disconnect = treated as **left immediately**; seat freed; counts update; relist logic applies.
* **Active state:**

  * Mark as left for counts but keep a **5-minute rejoin window** bound to the same `playerId`.
  * **AI takes over** instantly.
  * If the player **rejoins within 5 minutes**, reattach to their seat and stop AI.
  * Game never pauses; continues until all rounds complete.
* **If `playerCount==0`:** purge room immediately (see Section XV Rule #1).

---

## XIII. Room UI Requirements

**Room Cards (lists)**

* Show: room name & code, host crown, `X/Y` players, rounds, bet amount, lock icon if private, **Join** button (enabled only if joinable).
* Reflect updates within one network round-trip.

**In-Room (Waiting)**

* Avatars, names, ready checkmarks.
* Host-only controls for settings.

---

## XIV. Host Migration

* On host disconnect/leave, pick **lowest `joinOrder` still connected**.
* Broadcast `HOST_CHANGED` with new `hostId`.

---

## XV. **Event-Driven Cleanup & Listing Invariants (no intervals)**

All room visibility/cleanup happens **immediately** on the same transaction that mutates membership, settings, or state.

### Triggers

* **On create:** after commit → `ROOM_CREATED` + `ROOM_UPDATED`
* **On join/leave/disconnect/reconnect:** after commit → `PLAYER_JOINED|LEFT` + `ROOM_UPDATED`
* **On settings change:** after commit → `SETTINGS_UPDATED` + `ROOM_UPDATED`
* **On state change (waiting↔active↔finished):** after commit → `ROOM_UPDATED`

### Immediate Rules (atomic evaluation after each mutation)

1. **Empty room purge (hard rule)**
   If `playerCount == 0` → **delete room now** and emit `ROOM_DELETED`.
   *Note:* “Game continues” applies while **≥1** players remain. If AI-with-0-humans is desired later, that’s a new rule.

2. **Public room listing (Active Rooms panel)**

   * List iff `visibility=="public" && state=="waiting" && playerCount < maxPlayers`.
   * If a waiting room becomes **full** (`playerCount==maxPlayers`) → **immediately delist**.
   * If a previously full waiting room loses a player → **immediately relist**.

3. **State transitions**

   * `waiting → active` (auto-start): **immediate delist** (not joinable).
   * `active → finished`: not shown in Active Rooms. If host resets to `waiting` and room is joinable → **list immediately**.

4. **Private rooms**

   * Never appear in **Active Rooms**; access via password/invite only. Card shows lock for members wherever rendered.

### Ordering & Delivery Guarantees

* **DB first, sockets second:** commit DB tx → recompute invariants → emit events.
* **Idempotent diffs:** prefer `room:list:diff` to keep clients in sync without heavy payloads.
* **After-commit hooks only:** never broadcast from within an uncommitted transaction.

### Pseudocode (server-side)

```ts
function afterCommit(roomId: string) {
  const room = Rooms.get(roomId); // fresh read
  if (!room) { emit('room:deleted', { code: lastKnownCode }); return; }

  // 1) Empty purge
  if (room.playerCount === 0) {
    Rooms.delete(roomId);
    emit('room:deleted', { code: room.code });
    return;
  }

  // 2) Listing invariant
  const shouldList = room.visibility === 'public'
                  && room.state === 'waiting'
                  && room.playerCount < room.maxPlayers;

  emit('room:updated', { code: room.code, changes: deriveChanges(room), serverTs: now() });
  emit('room:list:diff', diffFor(room.code, shouldList)); // adds/updates/removes card
}
```

---

## XVI. REST (optional helpers; sockets remain source of truth)

* `POST /rooms` → create room
* `GET /rooms?visibility=public&state=waiting&joinable=true` → initial list (socket keeps it live)
* `POST /rooms/{code}/join`, `POST /rooms/{code}/leave`
* `PATCH /rooms/{code}/settings`
* `POST /rooms/{code}/ready`
* `POST /rooms/{code}/start`
* `GET /rooms/{code}/state`

**Idempotency:** use `Idempotency-Key` on create/join to avoid dupes.

---

## XVII. Acceptance Tests (behavioral)

1. **Create → list**
   Create public room (2–4 players) ⇒ **Active Rooms** shows new card with `1/Y` immediately.

2. **Join → full → delist**
   Join waiting public room with `X<Y` ⇒ all clients see `X+1/Y`; if `X+1==Y` ⇒ card **removed immediately**.

3. **Leave → relist**
   From previously full waiting room, one player leaves ⇒ `X-1/Y` and room **reappears immediately** in Active Rooms.

4. **Empty → purge**
   Last player leaves/disconnects ⇒ room **deleted immediately** and removed from lists.

5. **Settings update → reflect**
   Host changes max players/rounds/bet ⇒ room card and in-room UI update in real time.

6. **Ready → auto-start**
   ≥2 players and all ready ⇒ game starts, state=`active`, room **delists immediately**.

7. **Disconnect during active → AI + rejoin**
   During active game, a player disconnects ⇒ AI immediately controls that player; game continues. If they rejoin within **5 minutes**, they reclaim their seat.

---

## XVIII. Rate Limits & Errors (examples)

* **Join spam:** 429 `JOIN_RATE_LIMIT` (Retry-After)
* **Wrong password:** 403 `ROOM_PASSWORD_INVALID`
* **Room full/not waiting:** 409 `ROOM_NOT_JOINABLE`
* **Duplicate join:** 409 `ALREADY_IN_ROOM`
* **Not host for settings:** 403 `HOST_REQUIRED`
* **Illegal move:** 400 `MOVE_INVALID` (with reason)
* **Generic:** 500 `INTERNAL_ERROR` (with correlation id)

---

## XIX. Notes for Implementation

* Server clock discipline (NTP); include `serverTs` in all authoritative events.
* Use DB transactions around join/leave to keep counts correct; publish socket events **after commit**.
* Prefer **diff** updates (`room:list:diff`) once subscribed to minimize payload.
* Use **idempotency** keys on create/join; enforce unique `(roomId, playerId)`.
