# Self‑Debugging Autonomy Orders (for Claude 4.1 + Replit) — Rooms System

> **Intent:** You (Claude 4.1 on Replit) must implement **self‑diagnosing debugging** inside the Online Multiplayer **Rooms** codebase so you can detect, triage, and prove fixes **without the user debugging anything**. Do **not** change gameplay logic. Add observability and automatic triage around the exact problem areas reported.

## 0) Operating Mode

* Add a **Self‑Debug Mode** (config/env switch). In dev/staging, Self‑Debug Mode is **ON by default**.
* When Self‑Debug Mode is ON:

  * Emit **structured, single‑line logs** for every critical step (see Section 2).
  * Capture **redacted state snapshots** at key edges (Section 4).
  * Enforce **invariant assertions** and **automatic triage** (Sections 5–6).
  * After any attempted fix, run the **Auto Verification Suite** (Section 9) before telling the user it’s fixed.

## 1) Scope of Problems to Target (instrument these first)

1. **Room creation intermittently fails**; initial create often errors until retried.
2. **Auto‑start stalls**; all players ready, but game doesn’t transition to active.
3. **Game loads but is non‑functional**; UI mounted but actions/timers/state aren’t alive.

## 2) Exact Places to Add Diagnostics (server and client)

**Server handlers (each gets entry/validate/tx/after‑commit/assert/emit logs):**

* Room creation (`room:create` / `POST /rooms`)
* Join (`room:join`) and Leave/Disconnect (`room:leave`, socket close)
* Settings update (`room:settings:update`)
* Ready toggle (`room:ready:set`)
* Auto‑start path (triggered after any ready change while `state=waiting`)
* State transitions (waiting→active, active→finished, reset→waiting)
* Host migration decision (on host leave/disconnect)
* Game initialization entrypoint (first authoritative game state/seed)
* Emit/broadcast utility (the single place that sends messages to clients)

**Client (dev build only):**

* **Click‑path telemetry**: emit `ui.click` for join/create/ready/start buttons with control IDs.
* **Screen lifecycle**: emit `ui.screen_mounted` (room list, room waiting, game screen) with local state summary.
* **ACKs for critical events**: respond to server with `ack` and record timing.

## 3) Correlation & Identity (always present)

* Attach to every intent and log: `requestId`, `roomOpId`, `roomCode?`, `roomId?`, `playerId?`, `serverTs`, `protocolVersion`.
* Client includes `clientTs` so the server can compute skew and sequence.

## 4) State Snapshots (redacted)

Capture a compact snapshot at:

* After **room creation** commits
* After **auto‑start** decision commits
* On each **state transition**
* After **host migration** decision
* When **game initializes** (include RNG seed and current turn ID)

Snapshot fields (no PII): `roomId, code, state, playerCount, maxPlayers, visibility, hostId, players[{id,ready,connected,joinOrder}], rounds, bet, serverTs, protocolVersion, rngSeed?, turnId?`.

## 5) Invariant Assertions (evaluate post‑commit)

* `playerCount ≤ maxPlayers`
* `state ∈ {waiting, active, finished}`
* **Listing rule**: public + waiting + `playerCount < maxPlayers` ⇒ listed; else not listed
* `playerCount == 0` ⇒ room deleted immediately
* On failure in dev/staging: hard fail, fire triage (Section 6), and include the snapshot.

## 6) Automatic Triage Triggers & Actions

**Triggers** (any occurrence runs triage automatically):

* Room creation returns error or times out.
* All players ready for ≥2 seconds, but `state` ≠ `active`.
* Game screen mounted without receiving/ACKing the initial authoritative state within 1 second.
* Consecutive move rejections (>3) or timer not ticking for >2 seconds.
* Any invariant assertion failure.

**Triage actions (always):**

* Compile a **Triage Bundle**: last 50 logs for the request, latest snapshot(s), ack statistics, listing decision, and failure reason classification.
* **Classify cause** using these buckets (choose one, include decision data):

  * `IDEMPOTENCY_DUPLICATE` (duplicate create/join)
  * `EMIT_BEFORE_COMMIT` (broadcast sent pre‑commit)
  * `AUTOSTART_CONDITION_FALSE` (which precondition?)
  * `STATE_NOT_PERSISTED` (active flag not saved before emit)
  * `CLIENT_NOT_SUBSCRIBED` (no ACKs from any client)
  * `RNG_SEED_MISSING` / `INITIAL_STATE_MISSING`
  * `PROTOCOL_MISMATCH`
  * `LISTING_INVARIANT_MISMATCH`
* Store the Triage Bundle where you can retrieve it and summarize it for the user.

## 7) What You Must Report Back (plain English, no raw logs)

When you (Claude/Replit) say a fix is done, include:

* **Summary**: what was wrong (one‑line cause), what you changed (areas/files, not code), and why it fixes it.
* **Evidence**: a concise description of the Triage Bundle results (e.g., “ackRate 0.83 on `game:started`, state flipped at 123ms, listing decision=delisted as full”).
* **Verification**: which scenarios from Section 9 passed and how many runs.

## 8) Critical Events Requiring ACK Quorum

* `game:started`, `room:deleted`, `host:changed`, and `room:list:diff` publish
* Wait for ACKs with a **quorum** (e.g., ≥60%) and a short timeout; record `ackRate`. Low ACK rate automatically triggers triage.

## 9) Auto Verification Suite (run after any change before telling the user)

Run these scripted scenarios and record results:

1. **Create → list** (room appears immediately in Active Rooms)
2. **Join until full → instant delist**
3. **Leave from full → instant relist**
4. **All ready → auto‑start exactly once** (state flips, `game:started` acked)
5. **Disconnect during active → AI takeover → rejoin within window**
6. **Last player leaves → immediate delete**

For each, save a **Result Card** (pass/fail, timestamps, ackRate, snapshot IDs). If any fail, run triage and fix before reporting.

## 10) Idempotency & Conflicts (creation/join)

* Require an **idempotency key** on create/join intents.
* On key reuse, return the original outcome and label the event `IDEMPOTENCY_DUPLICATE` (do not error).
* Ensure room code uniqueness; on collision, regenerate and note `code.retryCount` in logs.

## 11) Client‑Side Dev HUD (Self‑Debug Mode only)

* Display: `room.state`, `X/Y`, `readyCount`, `hostId`, `protocolVersion`, `turnId`, `msRemaining` (from serverTs), and whether the last critical event was ACKed. This is for **you** (Claude) to confirm behavior—not for the user to parse.

## 12) Non‑Negotiables

* **Emit only after commit.** Never broadcast from inside an uncommitted transaction.
* **Never** log secrets or PII.
* Do **not** modify gameplay logic or timers without an explicit request.

## 13) Acceptance Gates (don’t tell the user “fixed” until these are true)

* 100/100 successful room creations with **no unknown errors** in Self‑Debug Mode.
* 100/100 auto‑starts when all players ready and ≥2 players present; `game:started` ackRate ≥0.6 in a degraded network simulation.
* 30‑minute soak with create/join/leave/ready churn, **zero invariant assertion failures**.

## 14) Final Directive

**Implement everything above now.** Then run the **Auto Verification Suite** and return to the user:

* A human‑readable **Summary** of root causes and changes (no code),
* The **Result Cards** for each scenario (pass/fail + key metrics),
* A note confirming Self‑Debug Mode can be switched off for production.

> You (Claude/Replit) are responsible for reading your own logs and triage bundles to diagnose and fix issues before replying that something is resolved.
